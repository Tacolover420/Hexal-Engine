<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>HexalEngine Demo</title>
    
    <link rel="stylesheet" type="text/css" href="/~tasimmons/plugin/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="main.css" />
    
    <!-- JQuery -->
    <script src="/~tasimmons/plugin/jquery/jquery.min.js"></script>
    
    <!-- Hexal Engine -->
    <script src="hexal.js"></script>
    
    <!-- Fractal Generation Script -->
    <!--<script src="gen.js"></sript>-->
  </head>

  <body>
    <div id="wrapper">
      <nav>
        <ul class="nav nav-pills pull-left">
          <li><a href="/~tasimmons/">Back to Home</a></li>
        </ul>
      </nav>
      <div class="container">
        
        <h1 class="text-center"><span class="text-hexal">HexalEngine</span> Demonstration</h1>
        <p class="lead text-center">
          HexalEngine is an isometric rendering engine that presents an array of objects (called "hexals") in an axial grid.<br>
          <small><small>
            Controls: <strong>Pan</strong> with mouse (click & drag) or arrow keys; <strong>Zoom</strong> in/out with +/-; <strong>Move slice</strong> with &lt;/&gt; or PgUp/PgDn
          </small></small><br>
          For the best experience, view in Chrome. Not intended for mobile devices. <strong>See below</strong> for an explanation of the project
        </p>
        
        <div id="map_container" class="text-right">
          <button id="toggle_fullscreen" class="btn btn-default text-center">FS</button>
          <canvas id="map">If you can read this, your browser is either out of date or does not support HTML5 Canvases. To fix this, simply download the latest version of Chrome, Firefox, Internet Explorer, Safari, Opera, or any other HTML5 canvas-compliant browser.
          </canvas>
        </div>
        
        <h4 class="text-center">Purpose</h4>
        <p>
          The point of this project is primarily for me to experiment with canvas, but it is also an excellent opportunity to learn healthy development practices. For instance, I have practiced quite a bit with git (culminating in a quite successful branching pattern and filesystem structure) and track bugs and planned features in Trello, now. Largely as a result of the complexity of the project, I have become more focused with careful planning and prototyping, leading to better code on the first draft; whiteboarding has become a regular exercise.
        </p>
        
        <h4 class="text-center">Technical Details</h4>
        <p>
          <dl class="dl-horizontal">
            <dt>Technology</dt>
            <dd>HexalEngine is written exclusively in vanilla JavaScript and renders via the HTML5 canvas element. As such, only modern, up-to-date browsers will be able to view this demonstration performantly. The engine exports a UI-API that is wired to browser events via JQuery (it is up to the implementing programmer to decide how best to trigger the UI-API; I use JQuery here to save time).</dd>
            <br>
            
            <dt>Object Structure</dt>
            <dd>HexalEngine has two primary datastructures, the HexalEngine prototype and the subordinate Hexal prototype. The latter is a small data collection used to track points in 2-space, the abstract component of the visible hexagons in the demo. The other prototype, HexalEngine, does the vast majority of the work, responsible for organizing, manipulating, and rendering Hexals as hexagons (it even knows how to create the hexagon rasters).</dd>
            <br>
            
            <dt>Axial Coordinates</dt>
            <dd>Axial coordinates are very similar to cartesian, except the two axes are not at a right angle. HexalEngine uses axial coordinates to place hexagons, which produces a coordinate system that is much more intelligible thana  staggered cartesian system (which was the implementation I chose in a preceding version.) Uniquely identifying Hexals is a slightly more laborious task, but can be achieved by counting outwards from the center of the map in rings (the id is derived by a finite integral sum, so the calculation is neat and performant). Obligatory: "I used Real Analysis for something!"</dd>
            <br>
            
            <dt>Graphics Processing</dt>
            <dd>
              <ul>
                <li>The hexagons that HexalEngine renders are not, indeed, true hexagons, because of the unfortunate fact that <em>true</em> hexagons have irrational side lengths. As such, they can not be rendered in discrete pixel units; that is, to render a true hexagon would be to trigger antialiasing (which can not be disabled in all browsers) or cause graphical artifacts on hexagon boundaries.</li>
                <li>Because of performance issues, extreme care must be taken when rendering <em>anything</em> to a canvas. The typical practice of prerendering in many steps is completely untenable in most browsers, especially since hardware acceleration is not always invoked opportunistically. HexalEngine subdivides the world into rectangular units ("chunks") which are prerendered a single time and cached as the client pans the map. The initial prerender step causes some lag but also triggers hardware acceleration, moving the raster images to the GPU and increasing draw speed thereafter. The chunks, by nature of being larger than individual hexagons, also allow large swaths of the map to be rendered in fewer steps (the canvas drawImage method has a significant amount of overhead, so colume of calls weights more than size of images.) Thus, by "chunking" the map into appropriately-sized units, HexalEngine is able to maximize performance by minimizing the number of draw steps per frame and triggering GPU acceleration.
                <li>HexalEngine only does as much work as it needs to. When chunks pan off-screen, they are not rendered, which is to be expected of ny rendering engine. Moreover, each draw step merely copies and translates the already-rendered screen, utilizing the preceding draw step as a sort of prerender step for the next. HexalEngine then must only fill in the gaps along the edges of the viewport, achieved by pasting chunks where appropriate. This step of translating the scene globs many draw operations into one, improving performance significantly.</li>
                <li>A noteworthy feature of HexalEngine is that it does <em>not</em> rerender chunks when the map is rescaled (zoomed). This was, at one point, an implementation feature that has since been replaced with clever css tricks: By altering the canvas width and height attributes independently of the css attributes of the same name, the browser will happily render a scaled-up or -down version of the scene very performantly. The only drawback of this method is the resolution does not change, so the quality of the image becomes distorted. This could be resolved via mipmapping.</li>
                <li>The most complex aspect of HexalEngine is rendering visible Hexals below the surface that (which may be partially obscured), creating the illusion of depth (2.5D, isometric display, psudo-3D, etc.) This is achieved through carefully optimized sampling, where the engine chooses points in space and "drills down" through the map until it finds an occupied space (think raycasting). The engine uses a few mathematical calculations (including GCD; obligatory: "I used Number Theory for something!") to minimize the number of points that must be sampled to the absolute minimum. This optimization results in a tidy performance gain, though this is hardly noticable with intelligent chunking (every little bit counts though, and the technology is all the more "really cool" because of it).</li>
              </ul>
            </dd>
            <br>
            
            <dt>Git</dt>
            <dd>With approximately 700 lines and a few rather complex spots of code, I thought it prudent to track the whole thing with Git. I currently have two repositories, one listed and the other unlisted, that I push and pull to a remote repository. This way, my public directory of code remains in a nice, stable state for the passer-by to examine while I work in my unlisted directory. Then I can just pull over my thoroughly-tested changes to show off recent development.</dd>
            <br>
          </dl>
        </p>
        
        <h4 class="text-center">Project Goals</h4>
        <p>
          These are all tracked on a Trello board, but I like to post a few to elucidate my interests:
          <ul>
            <li>Add functionality for users to select hexes. This is mostly done and is currently undergoing testing.</li>
            <li>Implement a fractal terrain generation algorithm. The algorithm is mostly done and is currently in the bugfixing stage.
              <ul>
                <li>This may involve creating an API that accepts a generation algorithm for convenience, but I could just take the well-formatted output of the algorithm and have it imported via a load function, instead.</li>
              </ul>
            </li>
            <li>Set up QUnit tests (sooner rather than later) for all potentially automatable tests.</li>
            <li>Create entity overlays for managing dynamic objects on the board.</li>
            <li>Create map load/save functionality.</li>
          </ul>
        </p>
        
        <small><small>The project is the intellectual property of Thomas Simmons. Do not use, copy, or distribute without permission.</small></small>
      </div><!-- container -->
    </div><!-- wrapper -->
  </body>
  
  <!-- Page Initialization -->
  <script src="main.js"></script>
</html>